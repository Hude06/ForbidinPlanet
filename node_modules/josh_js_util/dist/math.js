export function rand(min, max) {
    return min + Math.random() * (max - min);
}
export function lerp_number(t, s, e) {
    if (t <= 0)
        return s;
    if (t >= 1)
        return e;
    return s + (e - s) * t;
}
export function range(count) {
    let list = [];
    for (let i = 0; i < count; i++) {
        list.push(i);
    }
    return list;
}
export class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    add(pt) {
        return new Point(this.x + pt.x, this.y + pt.y);
    }
    subtract(pt) {
        return new Point(this.x - pt.x, this.y - pt.y);
    }
    multiply(point) {
        return new Point(this.x * point.x, this.y * point.y);
    }
    magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    scale(scale) {
        return new Point(this.x * scale, this.y * scale);
    }
    toString() {
        return `Point(${this.x.toFixed(1)},${this.y.toFixed(1)})`;
    }
    floor() {
        return new Point(Math.floor(this.x), Math.floor(this.y));
    }
    clamp(min, max) {
        let x = this.x;
        if (x < min.x)
            x = min.x;
        if (x > max.x)
            x = max.x;
        let y = this.y;
        if (y < min.y)
            y = min.y;
        if (y > max.y)
            y = max.y;
        return new Point(x, y);
    }
    clone() {
        return new Point(this.x, this.y);
    }
    toJSON() {
        return {
            x: this.x,
            y: this.y,
        };
    }
    static fromJSON(point) {
        return new Point(point.x, point.y);
    }
    lerp(t, that) {
        return new Point(lerp_number(t, this.x, that.x), lerp_number(t, this.y, that.y));
    }
}
export class Size {
    constructor(w, h) {
        this.w = w;
        this.h = h;
    }
    set(w, h) {
        this.w = w;
        this.h = h;
    }
    scale(scale) {
        return new Size(this.w * scale, this.h * scale);
    }
    asPoint() {
        return new Point(this.w, this.h);
    }
}
export class Insets {
    constructor(top, right, bottom, left) {
        this.top = top;
        this.right = right;
        this.bottom = bottom;
        this.left = left;
    }
}
export class Bounds {
    constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }
    get x2() {
        return this.x + this.w;
    }
    get y2() {
        return this.y + this.h;
    }
    contains(pt) {
        if (pt.x < this.x)
            return false;
        if (pt.y < this.y)
            return false;
        if (pt.x > this.x + this.w)
            return false;
        if (pt.y > this.y + this.h)
            return false;
        return true;
    }
    // intersects(b:Bounds):boolean {
    //     let p1 = b.position
    //     if(this.contains(p1)) return true
    //     let p2 = new Point(b.position.x+b.size.w,b.position.y)
    //     if(this.contains(p2)) return true
    //     let p3 = new Point(b.position.x+b.size.w,b.position.y+b.size.h)
    //     if(this.contains(p3)) return true
    //     let p4 = new Point(b.position.x,b.position.y+b.size.h)
    //     if(this.contains(p4)) return true
    //     return false
    // }
    set(number, number2, number3, h) {
        this.x = number;
        this.y = number2;
        this.w = number3;
        this.h = h;
    }
    add_self(point) {
        this.x += point.x;
        this.y += point.y;
    }
    add(point) {
        return new Bounds(this.x + point.x, this.y + point.y, this.w, this.h);
    }
    bottom() {
        return this.y + this.h;
    }
    left() {
        return this.x;
    }
    right() {
        return this.x + this.w;
    }
    top() {
        return this.y;
    }
    center() {
        return new Point(this.x + this.w / 2, this.y + this.h / 2);
    }
    intersects(other) {
        if (this.left() >= other.right())
            return false;
        if (this.right() <= other.left())
            return false;
        if (this.top() >= other.bottom())
            return false;
        if (this.bottom() <= other.top())
            return false;
        return true;
    }
    toString() {
        return `(${this.x.toFixed(1)},${this.y.toFixed(1)})x(${this.w.toFixed(1)},${this.h.toFixed(1)})`;
    }
    top_right() {
        return new Point(this.x + this.w, this.y);
    }
    bottom_right() {
        return new Point(this.x + this.w, this.y + this.h);
    }
    bottom_left() {
        return new Point(this.x, this.y + this.h);
    }
    top_left() {
        return new Point(this.x, this.y);
    }
    copy() {
        return new Bounds(this.x, this.y, this.w, this.h);
    }
    sides() {
        return new Insets(this.top(), this.right(), this.bottom(), this.left());
    }
}
//# sourceMappingURL=math.js.map